<script>
  import * as api from "api";
  import { getContext, onMount } from "svelte";
  import { fly } from "svelte/transition";
  import { stores } from "@sapper/app";
  import { post, getMedia, createRedirectSlug } from "utils";
  import { users } from "../../stores/userStore";
  import { flash } from "../../stores/flashStore";
  import Textfield from "@smui/textfield";
  import HelperText from "@smui/textfield/helper-text";
  import Button, { Label } from "@smui/button";
  import { Icon as CommonIcon } from "@smui/common";
  import Select, { Option } from "@smui/select";
  import { Icon as SelectIcon } from "@smui/select/icon";
  import { Icon as TextfieldIcon } from "@smui/textfield/icon";
  import Paper, { Title } from "@smui/paper";
  import Menu from "@smui/menu";
  import { Anchor } from "@smui/menu-surface";
  import List, { Item, Separator, Text } from "@smui/list";
  import Component from "./_Component.svelte";
  import MediaUploader from "./_MediaUploader.svelte";
  import Avatar from "./_Avatar.svelte";

  const { page, session } = stores();
  const { getSnackbar, configSnackbar } = getContext("snackbar");
  const { open } = getContext("simple-modal");

  const ACTIONS_TABLE = new Set([
    { action: "edit", name: "Benutzer bearbeiten" },
    { action: "pass", name: "Passwort bearbeiten" },
    { action: "del", name: "Benutzer löschen" },
  ]);
  const ADMIN_ACTIONS = ["edit", "pass", "del"];
  const USER_ACTIONS = ["edit"];

  const placeholder = "https://via.placeholder.com/100x100.png?text=";
  const passwordHint = "Das Passwort muss aus mind. 8 Zeichen bestehen";
  const passwordErrorMesssage = "Passwörter stimmern nicht überein";
  const invalidEmailMessage = "Keine gültige Email Adresse.";

  export let selectionUserId = null;
  export let selectedMode = "edit";

  let code;
  let user = $session.user;
  let groups = $session.groups;
  let filtered;
  let currentUser = {};
  let invalidEmail = false;
  let password = "";
  let repeatedPassword = "";
  let snackbar;
  let message;
  let avatarMenu;
  let avatarMenuAnchor;
  let src = "";

  $: invalidPassword = password.length < 8;
  $: invalidRepeatedPassword = password !== repeatedPassword || invalidPassword;
  $: currentUser =
    (filtered = ((id) => $users.filter((usr) => usr.id === id))(
      selectionUserId
    )) &&
    filtered.length &&
    filtered[0];
  $: _name = ((usr) => (usr && usr.name) || "")(
    selectedMode !== "add" ? currentUser : false
  );
  $: _email = ((usr) => (usr && usr.email) || "")(
    selectedMode !== "add" ? currentUser : false
  );
  $: _group_id = ((usr) => (usr && usr.group_id) || "")(
    selectedMode !== "add" ? currentUser : false
  );
  $: email = _email;
  $: name = _name;
  $: group_id = _group_id;
  $: canSave =
    selectedMode === "add"
      ? name && group_id && !invalidEmail && !invalidRepeatedPassword
      : name !== _name ||
        group_id != _group_id ||
        (email !== _email && !invalidEmail);
  $: canReset =
    name !== _name ||
    email !== _email ||
    group_id != _group_id ||
    password ||
    repeatedPassword;
  $: (() => resetPassword())(selectionUserId);
  $: componentHeader = currentUser
    ? `<strong>${currentUser.name}</strong>`
    : "Neuen Klienten anlegen";
  $: uid = currentUser.id;
  $: (async (usr) => {
    let res,
      avatar = usr.avatar;
    src = defaultAvatar(usr);
    if (avatar) {
      res = await getMedia("AVATAR", avatar.id, user, {
        width: 100,
        height: 100,
        square: 1,
      });
      if (res) src = res;
    }
  })(currentUser);
  $: isAdmin = $session.role === "Administrator";
  $: actions = isAdmin ? ADMIN_ACTIONS : USER_ACTIONS;
  $: userCanDo = ((ua) =>
    [...ACTIONS_TABLE].filter((s) => ua.find((u) => s.action === u)))(actions);

  onMount(() => {
    snackbar = getSnackbar();
  });

  function defaultAvatar(user) {
    let name = user.name || "?";
    return `${placeholder}${name
      .split(" ")
      .map((val) => val.substring(0, 1))
      .join("")}`;
  }

  let openUploader = () => {
    open(
      MediaUploader,
      {
        type: "avatar",
        uid,
        options: {
          parallelUploads: 1,
          maxFiles: 1,
        },
        events: { uploadDone },
      },
      {
        transitionWindow: fly,
        transitionWindowProps: {
          y: -200,
          duration: 500,
        },
      }
    );
  };

  async function uploadDone(e) {
    users.put(e.detail);
    // have we updated the loggedin users avatar?
    // since the loggedin user is in a different store (the session store)
    // put the newly uploaded avatar there
    // this also means we have to persist the new user value(s) in the node server session
    if (user.id === e.detail.id) {
      let config = ["avatar"];
      const res = await post("auth/save", { user: e.detail, config });
      if (res.success) {
        config.map((itm) => ($session.user[itm] = res.data[itm]));
      }
    }
  }

  async function deleteAvatar() {
    const res = await api.del(
      `avatars/${currentUser.avatar.id}`,
      user && user.token
    );
    if (res.success) {
      users.put(res.data);
    }
    if (user.id === currentUser.id) {
      let config = "avatar";
      const res = await post("auth/save", { user: currentUser, config });
      if (res.success) {
        $session.user[config] = res.data[config];
      }
    }
  }

  async function submit() {
    let res, data, path, action;
    snackbar.isOpen && snackbar.close();

    switch (selectedMode) {
      case "add":
        data = { email, name, password, group_id, active: true };
        res = await api.post(`users/add`, data, user && user.token);
        break;
      case "edit":
      case "pass":
        data = password
          ? { email, name, group_id, password }
          : { email, name, group_id };
        res = await api.put(
          `users/${selectionUserId}`,
          data,
          user && user.token
        );
        break;
      case "del":
        if (
          !confirm(`${name} will be permanently removed. Confirm pressing OK`)
        )
          return;
        res = await api.del(`users/${selectionUserId}`, user && user.token);
        break;
    }

    // TODO handle network errors
    message = res.message || res.data.message || res.statusText;
    code = (res.data && res.data.code) || res.status;

    if (res.success) {
      switch (selectedMode) {
        case "add":
          // refresh users and jump to new user
          const resUsers = await api.get("users", user && user.token);
          if (resUsers.success) {
            users.update(resUsers.data);

            path = `users/${res.data.id}?tab=user`;
            action = "Goto new user";
            configSnackbar(message, { path, action });
            snackbar.open();
          }
          break;
        case "pass":
          resetPassword();
        case "edit":
          users.put({ ...currentUser, ...data });

          configSnackbar(message);
          snackbar.open();
          break;
        case "del":
          users.del(selectionUserId);
          selectionUserId = null;

          configSnackbar(message, "users");
          snackbar.open();
      }
    } else if (200 < code && code < 500) {
      // Sample Users are protected
      configSnackbar(message);
      snackbar.open();
    } else {
      flash.update({ type: "error", message });

      path = `login${createRedirectSlug($page)}`;
      configSnackbar(message, path);
      snackbar.open();
    }
  }

  function reset(e) {
    e.preventDefault();
    email = _email;
    name = _name;
    group_id = _group_id;
    resetPassword();
  }

  function resetPassword() {
    password = repeatedPassword = "";
  }
</script>

<style>
  form {
    position: relative;
  }
  .grid-item {
    background: var(--back-grid-item);
  }
  .user {
    grid-area: one;
    overflow: auto;
  }
  .user-items {
    display: flex;
    flex-direction: column;
  }
  .item {
    margin-bottom: 2rem;
  }
  .select-item {
    margin-bottom: 2rem;
  }
  :global(.item > label) {
    width: 100%;
  }
  .no-selection {
    align-self: center;
    min-width: 29%;
    text-align: center;
    display: inline-block;
  }
  .alert {
    display: table;
    margin-bottom: 1em;
  }
  .avatar-container {
    display: flex;
    justify-content: flex-end;
    position: absolute;
    right: 50px;
    top: 20px;
    z-index: 1;
  }
  .avatar-container :global(img) {
    cursor: pointer;
  }
</style>

<div class="grid-item user" style="height: 100%;">
  <Component extended>
    <div slot="header">
      <h2>
        {@html componentHeader}
      </h2>
    </div>
    <div class="">
      {#if selectionUserId}
        <div class="avatar-container" on:click={() => avatarMenu.setOpen(true)}>
          <div bind:this={avatarMenuAnchor} use:Anchor>
            <Avatar {src} size="lg" />
            <Menu
              bind:this={avatarMenu}
              anchor={false}
              bind:anchorElement={avatarMenuAnchor}
              anchorCorner="TOP_END">
              <List>
                <Item on:click={() => openUploader()}>
                  <Text>Avatar ändern</Text>
                </Item>
                <Item
                  disabled={!currentUser.avatar}
                  on:click={() => deleteAvatar()}>
                  <Text>Avatar löschen</Text>
                </Item>
              </List>
            </Menu>
          </div>
        </div>
      {/if}
      <form on:submit|preventDefault={submit} method="post">
        <div class="user-items">
          {#if selectedMode !== 'add'}
            <div class="select-item">
              <Select
                enhanced
                bind:value={selectedMode}
                label="Select Mode"
                class="select-width"
                menu$class="select-width"
                variant="filled">
                <Option value="" />
                {#each userCanDo as canDo}
                  <Option
                    value={canDo.action}
                    selected={selectedMode === canDo.action}>
                    {canDo.name}
                  </Option>
                {/each}
              </Select>
            </div>
          {/if}
          {#if selectedMode === 'add' || selectedMode === 'edit'}
            <div class="item">
              <Textfield
                bind:value={email}
                bind:invalid={invalidEmail}
                label=""
                type="email"
                updateInvalid
                input$autocomplete="email">
                <span slot="label"><CommonIcon
                    class="material-icons"
                    style="font-size: 1em; line-height: normal; vertical-align: middle;">
                    email
                  </CommonIcon>
                  Email</span>
              </Textfield>
              <HelperText validationMsg>{invalidEmailMessage}</HelperText>
            </div>
            <div class="item">
              <Textfield
                withLeadingIcon
                bind:value={name}
                label="Name"
                type="text"
                input$aria-controls="helper-text-standard-b"
                input$aria-describedby="helper-text-standard-b">
                <TextfieldIcon class="material-icons">
                  contact_page
                </TextfieldIcon>
              </Textfield>
              <HelperText id="helper-text-standard-b">Ihr Name</HelperText>
            </div>
            <div class="item">
              <Select
                disabled={!isAdmin}
                withLeadingIcon
                bind:value={group_id}
                label="Benutzerrolle"
                class="select-width"
                menu$class="select-width">
                <span slot="icon"><SelectIcon class="material-icons">
                    contact_page
                  </SelectIcon></span>
                <Option value="" />
                {#each groups as group}
                  <Option value={group.id} selected={group_id === group.id}>
                    {group.name}
                  </Option>
                {/each}
              </Select>
            </div>
          {/if}
          {#if selectedMode === 'add' || selectedMode === 'pass'}
            <div class="item">
              <Textfield
                withLeadingIcon
                type="password"
                bind:invalid={invalidPassword}
                bind:value={password}
                label="Passwort"
                input$aria-controls="helper-password"
                input$aria-describedby="helper-password"
                style="min-width: 250px;">
                <TextfieldIcon class="material-icons">
                  fingerprint
                </TextfieldIcon>
              </Textfield>
              <HelperText id="helper-password">{passwordHint}</HelperText>
            </div>
            <div class="item">
              <Textfield
                withLeadingIcon
                type="password"
                disabled={invalidPassword}
                bind:invalid={invalidRepeatedPassword}
                class=""
                bind:value={repeatedPassword}
                label="Passwort wiederholen"
                input$aria-controls="helper-password-repeat"
                input$aria-describedby="helper-password-repeat">
                <TextfieldIcon class="material-icons">
                  fingerprint
                </TextfieldIcon>
              </Textfield>
              <HelperText id="helper-password-repeat">
                {passwordErrorMesssage}
              </HelperText>
            </div>
          {/if}
          {#if selectedMode === 'add' || selectedMode === 'edit' || selectedMode === 'pass'}
            <div class="item">
              {#if selectedMode !== 'pass'}
                <Button
                  disabled={!canSave}
                  color="primary"
                  variant="unelevated">
                  <Label>Speichern</Label>
                  <CommonIcon class="material-icons">save</CommonIcon>
                </Button>
              {:else}
                <Button
                  disabled={invalidRepeatedPassword}
                  color="primary"
                  variant="unelevated">
                  <Label>Passwort wiederholen</Label>
                  <CommonIcon class="material-icons">fingerprint</CommonIcon>
                </Button>
              {/if}
              <Button
                disabled={!canReset}
                color="primary"
                on:click={reset}
                variant="unelevated">
                <Label>Zurücksetzen</Label>
                <CommonIcon class="material-icons">
                  settings_backup_restore
                </CommonIcon>
              </Button>
            </div>
          {/if}
          {#if selectedMode === 'del'}
            <div class="item">
              <div class="alert" role="alert">
                <div
                  class="bg-red-500 text-white font-bold rounded-t px-4 py-2">
                  Achtung!
                </div>
                <div
                  class="border border-t-0 border-red-400 rounded-b bg-red-100 px-4 py-3 text-red-700">
                  <p>Dieser Vorgang kann nicht rückgängig gemacht werden!</p>
                </div>
              </div>
              <Button color="primary" variant="unelevated">
                <Label>Jaa, endgültig löschen</Label>
                <CommonIcon class="material-icons">delete</CommonIcon>
              </Button>
            </div>
          {/if}
          {#if !selectedMode}
            <div class="no-selection">
              <Paper color="primary">
                <Title style="color: var(--text-light)">
                  Select Edit Mode
                  {selectedMode}
                </Title>
              </Paper>
            </div>
          {/if}
        </div>
      </form>
    </div>
  </Component>
</div>
